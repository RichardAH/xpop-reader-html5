<html>
<head>
    <title>Html-Qrcode Demo</title>
<style>
.output {
    max-width: 100%;
    line-break: anywhere;
}
</style>
<script src="html5-qrcode.min.js"></script>
<script src="brotli.js"></script>
<script defer>

    function decode_ascii85(a) { //https://stackoverflow.com/a/31741111
      var c, d, e, f, g, h = String, l = "length", w = 255, x = "charCodeAt", y = "slice", z = "replace";
      for ("<~" === a[y](0, 2) && "~>" === a[y](-2), a = a[y](2, -2)[z](/\s/g, "")[z]("z", "!!!!!"), 
      c = "uuuuu"[y](a[l] % 5 || 5), a += c, e = [], f = 0, g = a[l]; g > f; f += 5) d = 52200625 * (a[x](f) - 33) + 614125 * (a[x](f + 1) - 33) + 7225 * (a[x](f + 2) - 33) + 85 * (a[x](f + 3) - 33) + (a[x](f + 4) - 33), 
      e.push(w & d >> 24, w & d >> 16, w & d >> 8, w & d);
      return function(a, b) {
        for (var c = b; c > 0; c--) a.pop();
      }(e, c[l]), h.fromCharCode.apply(h, e);
    }


    function docReady(fn) {
        // see if DOM is already available
        if (document.readyState === "complete"
            || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }

    docReady(function () {
        var resultContainer = document.getElementById('qr-reader-results');
        var lastResult, countResults = 0;
        let frames = {}
        let parity_frames = {}
        let reconstructions = [];
        let total = 0;

        // whenever we get a parity frame we will iterate to see if we can build any missing frames from it
        function attempt_reconstructions()
        {
            // it's always the case that we are attempting to reconstruct the left most needed frame using the first
            // encompassing parity frame

            let reconstruction_successful = false;

            while (true)
            {
                for (let i = 1; i <= total; ++i)
                if (!(i in frames))
                {
                    // frame `i` is needed
                    // check if we have a parity frame that can rebuild it
                    parity_checkpoints = Object.keys(parity_frames).sort();
                    for (let j = 0; j < parity_checkpoints; ++j)
                    if (parity_checkpoints[j] > i)
                    {
                        let point = parity_checkpoints[j]
                        // we found a candidate parity frame, but now check if we're eligable to use it
                        let missing = 0;
                        for (let m = 1; m <= point; ++m)
                            if (!(m in frames))
                                missing++;

                        if (missing == 1)
                        {
                            // we can reconstruct the missing frame
                            // to reconstruct we use the additive inverse on mod 85 against the parity frame
                            // using the frames we do have

                            let p = parity_frames[point];
                            for (let m = 1; m <= point; ++m)
                            if (m in frames)
                            {
                                let f = frames[m];
                                for (let x = 0; x < f.length; ++x)
                                {
                                    let inv = ((85 - (f.charCodeAt(x) - 33)) + p[x]) % 85;
                                    p[x] = inv;
                                }
                            }

                            let new_frame = "";

                            for (let x = 0; x < p.length; ++x)
                                new_frame = String.fromCharCode(33 + p[x]);

                            delete parity_frames[point];

                            frames[i] = new_frame;

                            console.log("reconstructed frame " + i, frames[i])

                            reconstructions.push(i);
                            reconstruction_successful = true;
                        }
                    }
                    break;
                }

                if (!reconstruction_successful)
                    return;
            }
        }


        let done = false
        function onScanSuccess(decoded, decodedResult) {
            if (decoded !== lastResult) {
                ++countResults;
                lastResult = decoded;
                // Handle on success condition with the decoded message.
                
                console.log(`Scan result ${decoded}`, decodedResult);
                if (done)
                    return;
                if (decoded.slice(0,4) == 'XPAR')
                {
                    let upto = parseInt(decoded.slice(6,8), 16);
                    
                    document.getElementById('qr-last').innerHTML = 'Just scanned parity #' + upto;

                    if (upto in parity_frames)
                        return;

                    let raw_parity = new Uint8Array(decoded.length - 8);
                    
                    for (let i = 8; i < decoded.length; ++i)
                        raw_parity[i-8] = decoded.charCodeAt(i) - 33; 
                    
                    parity_frames[upto] = raw_parity;
                    
                    attempt_reconstructions();

                }
                else if (decoded.slice(0,4) == 'XPOP')
                {

                    try
                    {
                        let frame = parseInt(decoded.slice(4,6), 16)
                        total = parseInt(decoded.slice(6,8), 16)
                        
                        document.getElementById('qr-last').innerHTML = 'Just scanned frame #' + frame;

                        if (frame in frames)
                            return;

                        frames[frame] = decoded.slice(8);

                        attempt_reconstructions();

                    }
                    catch (e) 
                    {
                        console.log(e)
                    }
                    
                    needed = [];
                    for (let i = 1; i <= total; ++i)
                        if (!(i in frames))
                            needed.push(i);
                            
        
                    parity = Object.keys(parity_frames);
        
                    resultContainer.innerHTML = 
                    '<div class="output">' + 
                        Math.floor((Object.keys(frames).length / total)*100) + '% - need ' + 
                        (total - Object.keys(frames).length) + ' more. Still needed: <br />' +
                        JSON.stringify(needed).replaceAll('"', '') +
                        '<br/><font color="blue">Parity frames:<br/>' +
                        JSON.stringify(parity).replaceAll('"', '') + '</font>' +
                        '<br/><font color="red">Reconstructed frames:<br />' +
                        JSON.stringify(reconstructions).replaceAll('"', '') + '</font>' +
                        '</div>';

                    if (Object.keys(frames).length >= total)
                    {
                        done = true
                        let full_payload = "<~"
                        for (let i = 1; i <= total; ++i)
                            full_payload += frames[i]

                        full_payload += "~>"

                        let binstr = decode_ascii85(full_payload)

                        let a = new Uint8Array(binstr.length)

                        for (let i = 0; i < binstr.length; ++i)
                            a[i] = binstr.charCodeAt(i)

                        let brotli = new Brotli()
                        let decomp = brotli.decompressArray(a)
            
                        out = ""
                        for (let i = 0; i < decomp.length; ++i)
                            out += String.fromCharCode(decomp[i])
                        
                        resultContainer.innerHTML = '<div class="output">' + out + '</div>'
                    } 
                }
            }
        }

        var html5QrcodeScanner = new Html5QrcodeScanner(
            "qr-reader", { fps: 60, qrbox: 250 });
        html5QrcodeScanner.render(onScanSuccess);
    });
</script>
</head>
<body>
    <div id="qr-reader" style="width:500px"></div>
    <div id="qr-last"></div>
    <div id="qr-reader-results"></div>
</body>
</html>
